//go:build ignore

package main

import (
	"log"

	"github.com/nekrassov01/aws-describer/internal/tmpl"
)

type templateData struct {
	FuncName    string
	Items       string
	ResultType  string
	Lister      string
	IterateStmt string
}

func gen(filePath string, data templateData) error {
	template := `// Code generated by api/s3/s3_gen.go. DO NOT EDIT.

package s3

import (
	"context"
	"runtime"
	"slices"
	"sync"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"golang.org/x/sync/errgroup"
	"golang.org/x/time/rate"
)

func {{ .FuncName }}(ctx context.Context, client IS3Client, names []string, document bool, filters []string) ([]{{ .ResultType }}, error) {
	eg, ctx := errgroup.WithContext(ctx)
	l := rate.NewLimiter(rate.Limit(50), 1)
	ich := make(chan {{ .ResultType }}, runtime.NumCPU())
	var info []{{ .ResultType }}
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := range ich {
			info = append(info, i)
		}
	}()
	o, err := client.{{ .Lister }}(ctx, &s3.{{ .Lister }}Input{})
	if err != nil {
		return nil, err
	}
	for _, item := range o.{{ .Items }} {
		item := item
		if len(names) > 0 && !slices.Contains(names, aws.ToString(item.Name)) {
			continue
		}
		eg.Go(func() error {
			if err := l.Wait(ctx); err != nil {
				return err
			}
			{{ .IterateStmt }}
			return nil
		})
	}
	if err := eg.Wait(); err != nil {
		close(ich)
		return nil, err
	}
	close(ich)
	wg.Wait()
	return info, nil
}`
	if err := tmpl.RenderTemplate("s3", template, filePath, data); err != nil {
		return err
	}
	return nil
}

func main() {
	params := []struct {
		filePath string
		data     templateData
	}{
		{
			filePath: "s3/s3_bucket_default.go",
			data: templateData{
				FuncName:   "ListBucketInfo",
				Items:      "Buckets",
				ResultType: "BucketInfo",
				Lister:     "ListBuckets",
				IterateStmt: `if err := GetBucketInfo(ctx, client, ich, item, document, filters); err != nil {
					return err
				}`,
			},
		},
	}
	for _, param := range params {
		if err := gen(param.filePath, param.data); err != nil {
			log.Fatal(err)
		}
	}
}
